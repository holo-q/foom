1. p_approx_np_implies_p_eq_np relies on strong assumptions about the nature of the probabilistic space that may not be fully justified. fuck
2. need to rigorously define the measure space over computations (1)
3. is the complexity-respecting measure actually well-defined? (2)
4. what if the integral doesn't converge for some languages? (3)
5. maybe we need to use a different notion of convergence for the infinite sums (4)
6. could use nets instead of sequences for more generality (5)
7. the chernoff bound might not apply in all cases, need to check conditions (1)
8. what if the probability distribution isn't independent for all inputs? (7)
9. could use martingale theory to handle dependent probabilities (8)
10. maybe the central limit theorem could be applied somewhere (9)
11. need to justify the use of fubini's theorem in the proof (3)
12. what if the space of computations isn't separable? (11)
13. could use descriptive set theory to handle non-separable spaces (12)
14. the notion of approximation might be too weak, need stronger bounds (1)
15. could use uniform convergence instead of pointwise (14)
16. what about languages that are on the "boundary" of P and NP? (15)
17. maybe there's a way to characterize these boundary languages (16)
18. could use ideas from fuzzy set theory for boundary cases (17)
19. the proof assumes countable choice, is this necessary? (1)
20. what happens in models of ZF without choice? (19)
21. could reformulate everything in terms of topos theory (20)
22. what about intuitionistic logic? does the proof still work? (21)
23. need to check if the law of excluded middle is used anywhere crucial (22)
24. could the proof be formalized in coq or lean? (23)
25. what about homotopy type theory? could it offer new insights? (24)
26. the use of classical probability theory might be limiting (1)
27. could quantum probability theory be more appropriate? (26)
28. what about p-adic probability theory? (27)
29. the proof assumes the church-turing thesis, is this justified? (1)
30. what about hypercomputation models? (29)
31. could we use infinite time turing machines? (30)
32. what about malament-hogarth spacetimes for hypercomputation? (31)
33. the proof implicitly assumes ZFC, what about alternate set theories? (1)
34. could new foundation (NF) offer a different perspective? (33)
35. what about paraconsistent set theories? (34)
36. the proof might not work in non-standard models of arithmetic (1)
37. could we use non-standard analysis techniques? (36)
38. what about surreal numbers for a finer-grained analysis? (37)
39. the proof assumes classical logic, what about linear logic? (22)
40. could substructural logics offer new insights? (39)
41. what about categorical logic? (40)
42. the proof might be too syntactic, need more semantic arguments (1)
43. could we use model theory to strengthen the results? (42)
44. what about infinitary logics? (43)
45. the proof assumes standard notions of complexity, what about fine-grained complexity? (1)
46. could we use resource-bounded complexity classes? (45)
47. what about space complexity? (46)
48. the proof focuses on time complexity, what about query complexity? (47)
49. could we use communication complexity ideas? (48)
50. what about quantum query complexity? (49)
51. the proof assumes standard turing machines, what about alternating turing machines? (1)
52. could we use branching programs? (51)
53. what about boolean circuits? (52)
54. the proof might not work for uniform complexity classes (1)
55. could we use logical characterizations of complexity classes? (54)
56. what about descriptive complexity theory? (55)
57. the proof assumes discrete computation, what about analog computation? (1)
58. could we use continuous time models? (57)
59. what about neural network models of computation? (58)
60. the proof might not work for average-case complexity (1)
61. could we use ideas from smoothed analysis? (60)
62. what about parameterized complexity? (61)
63. the proof assumes classical randomness, what about algorithmic randomness? (1)
64. could we use kolmogorov complexity in the proof? (63)
65. what about logical depth? (64)
66. the proof might not handle non-uniform complexity classes well (1)
67. could we use circuit lower bounds techniques? (66)
68. what about barriers like natural proofs? (67)
69. the proof assumes standard notions of reduction, what about fine-grained reductions? (1)
70. could we use truth-table reductions? (69)
71. what about non-uniform reductions? (70)
72. the proof might not work for space-bounded complexity classes (1)
73. could we use savitch's theorem somehow? (72)
74. what about simultaneous time-space bounds? (73)
75. the proof assumes deterministic verification, what about interactive proofs? (1)
76. could we use zero-knowledge proofs? (75)
77. what about probabilistically checkable proofs? (76)
78. the proof might not handle quantum complexity classes well (1)
79. could we use quantum fourier sampling? (78)
80. what about quantum walk algorithms? (79)
81. the proof assumes classical oracles, what about quantum oracles? (1)
82. could we use quantum black-box lower bounds? (81)
83. what about quantum-classical separations? (82)
84. the proof might not work for restricted models of computation (1)
85. could we use constant-depth circuits? (84)
86. what about monotone circuits? (85)
87. the proof assumes unlimited precision, what about fixed-point arithmetic? (1)
88. could we use interval arithmetic? (87)
89. what about exact real arithmetic? (88)
90. the proof might not handle algebraic complexity well (1)
91. could we use arithmetic circuits? (90)
92. what about algebraic decision trees? (91)
93. the proof assumes standard complexity measures, what about generic complexity? (1)
94. could we use resource-bounded measure theory? (93)
95. what about dimension in complexity theory? (94)
96. the proof might not work for promise problems (1)
97. could we use unique games conjecture ideas? (96)
98. what about dichotomy theorems? (97)
99. the proof assumes standard notions of approximation, what about inapproximability? (1)
100. could we use probabilistically checkable proofs of proximity? (99)
101. what about gap-preserving reductions? (100)
102. the proof might not handle quantum approximation well (78)
103. could we use quantum approximate optimization algorithms? (102)
104. what about variational quantum eigensolvers? (103)
105. the proof assumes classical error correction, what about quantum error correction? (1)
106. could we use fault-tolerant quantum computation? (105)
107. what about topological quantum computation? (106)
108. the proof might not work for restricted quantum circuits (78)
109. could we use clifford circuits? (108)
110. what about matchgate circuits? (109)
111. the proof assumes standard notions of uniformity, what about derandomization? (1)
112. could we use pseudorandom generators? (111)
113. what about hardness vs randomness tradeoffs? (112)
114. the proof might not handle relativized complexity well (1)
115. could we use oracle separation techniques? (114)
116. what about relativization barriers? (115)
117. the proof assumes classical cryptography, what about quantum cryptography? (1)
118. could we use quantum key distribution? (117)
119. what about post-quantum cryptography? (118)
120. the proof might not work for one-way functions (1)
121. could we use lattice-based cryptography? (120)
122. what about fully homomorphic encryption? (121)
123. the proof assumes standard notions of hardness, what about average-case hardness? (1)
124. could we use worst-case to average-case reductions? (123)
125. what about fine-grained average-case hardness? (124)
126. the proof might not handle streaming algorithms well (1)
127. could we use sketching techniques? (126)
128. what about communication complexity lower bounds? (127)
129. the proof assumes unlimited memory, what about memory-restricted models? (1)
130. could we use streaming lower bounds? (129)
131. what about communication-space tradeoffs? (130)
132. the proof might not work for distributed computing models (1)
133. could we use locality-sensitive hashing? (132)
134. what about distributed graph algorithms? (133)
135. the proof assumes centralized computation, what about federated learning? (1)
136. could we use differential privacy? (135)
137. what about secure multi-party computation? (136)
138. the proof might not handle online algorithms well (1)
139. could we use competitive analysis? (138)
140. what about advice complexity? (139)
141. the proof assumes static inputs, what about dynamic algorithms? (1)
142. could we use amortized analysis? (141)
143. what about fully dynamic graph algorithms? (142)
144. the proof might not work for property testing (1)
145. could we use distribution testing? (144)
146. what about tolerant testing? (145)
147. the proof assumes exact computation, what about approximate computing? (1)
148. could we use probabilistic bit streams? (147)
149. what about analog computation? (148)
150. the proof might not handle fine-grained complexity well (45)
151. could we use fine-grained reductions? (150)
152. what about conditional lower bounds? (151)
153. the proof assumes standard notions of hardness, what about cryptographic hardness? (1)
154. could we use indistinguishability obfuscation? (153)
155. what about multilinear maps? (154)
156. the proof might not work for succinct representations (1)
157. could we use implicit complexity? (156)
158. what about descriptive complexity? (157)
159. the proof assumes classical verification, what about quantum verification? (75)
160. could we use quantum interactive proofs? (159)
161. what about quantum merlin-arthur protocols? (160)
162. the proof might not handle quantum supremacy well (78)
163. could we use random circuit sampling? (162)
164. what about boson sampling? (163)
165. the proof assumes standard notions of reduction, what about truth-table reductions? (69)
166. could we use non-adaptive reductions? (165)
167. what about reductions in the quantum setting? (166)
168. the proof might not work for decision tree complexity (1)
169. could we use certificate complexity? (168)
170. what about sensitivity and block sensitivity? (169)
171. the proof assumes classical boolean functions, what about quantum boolean functions? (1)
172. could we use quantum query complexity? (171)
173. what about quantum certificate complexity? (172)
174. the proof might not handle algebraic complexity well (90)
175. could we use arithmetic circuits? (174)
176. what about tropical mathematics? (175)
177. the proof assumes standard complexity classes, what about semantic classes? (1)
178. could we use promise problems? (177)
179. what about classes with advice? (178)
180. the proof might not work for counting complexity classes (1)
181. could we use approximate counting? (180)
182. what about holographic algorithms? (181)
183. the proof assumes classical nondeterminism, what about quantum nondeterminism? (1)
184. could we use quantum witnesses? (183)
185. what about quantum certificate complexity? (184)
186. the proof might not handle parallelization well (1)
187. could we use parallel algorithms? (186)
188. what about parallel complexity theory? (187)
189. the proof assumes standard notions of efficiency, what about fine-grained complexity? (45)
190. could we use strong exponential time hypothesis? (189)
191. what about orthogonal vectors hypothesis? (190)
192. the proof might not work for sublinear time algorithms (1)
193. could we use property testing? (192)
194. what about local computation algorithms? (193)
195. the proof assumes classical sampling, what about quantum sampling? (1)
196. could we use quantum approximate optimization algorithms? (195)
197. what about variational quantum algorithms? (196)
198. the proof might not handle quantum error correction well (105)
199. could we use stabilizer codes? (198)
200. what about topological quantum codes? (199)
201. the proof assumes standard notions of universality, what about quantum universality? (1)
202. could we use universal quantum gates? (201)
203. what about measurement-based quantum computation? (202)
204. the proof might not work for restricted quantum models (108)
205. could we use linear optical quantum computing? (204)
206. what about adiabatic quantum computation? (205)
207. the proof assumes classical reversibility, what about quantum reversibility? (1)
208. could we use reversible circuits? (207)
209. what about Landauer's principle? (208)
210. the proof might not handle quantum communication complexity well (1)
211. could we use quantum fingerprinting? (210)
212. what about quantum teleportation? (211)
213. the proof assumes classical information theory, what about quantum information theory? (1)
214. could we use quantum entropy? (213)
215. what about quantum channel capacity? (214)
216. the proof might not work for quantum cryptography (117)
217. could we use quantum key distribution? (216)
218. what about quantum digital signatures? (217)
219. the proof assumes classical zero-knowledge, what about quantum zero-knowledge? (75)
220. could we use quantum commitments? (219)
221. what about quantum oblivious transfer? (220)
222. the proof might not handle quantum money well (1)
223. could we use public-key quantum money? (222)
224. what about quantum lightning? (223)
225. the proof assumes classical pseudorandomness, what about quantum pseudorandomness? (1)
226. could we use quantum pseudorandom generators? (225)
227. what about quantum t-designs? (226)
228. the proof might not work for quantum supremacy (162)
229. could we use cross-entropy benchmarking? (228)
230. what about quantum volume? (229)
231. the proof assumes classical error correction, what about quantum error mitigation? (105)
232. could we use dynamical decoupling? (231)
233. what about quantum error extrapolation? (232)
234. the proof might not handle quantum advantage well (1)
235. could we use variational quantum algorithms? (234)
236. what about quantum-inspired classical algorithms? (235)
237. the proof assumes classical oracles, what about quantum oracles with superposition queries? (81)
238. could we use quantum-walk-based algorithms? (237)
239. what about quantum adversary methods? (238)
240. the proof might not work for quantum-classical hybrid algorithms (1)
241. could we use quantum-classical variational algorithms? (240)
242. what about quantum-assisted optimization? (241)
243. the proof assumes classical annealing, what about quantum annealing? (1)
244. could we use adiabatic quantum computation? (243)
245. what about quantum approximate optimization algorithms? (244)
246. the proof might not handle quantum machine learning well (1)
247. could we use quantum support vector machines? (246)
248. what about quantum neural networks? (247)
249. the proof assumes classical dimensionality reduction, what about quantum dimensionality reduction? (1)
250. could we use quantum principal component analysis? (249)
251. what about quantum autoencoders? (250)
252. the proof might not work for quantum metrology (1)
253. could we use quantum fisher information? (252)
254. what about heisenberg-limited sensing? (253)
255. the proof assumes classical sensing, what about quantum sensing? (1)
256. could we use nitrogen-vacancy centers? (255)
257. what about squeezed states? (256)
258. the proof might not handle quantum simulation well (1)
259. could we use trotterization? (258)
260. what about qubitization? (259)
261. the proof assumes classical computation graphs, what about quantum computation graphs? (1)
262. could we use zx-calculus? (261)
263. what about quantum tensor networks? (262)
264. the proof might not work for quantum-inspired classical algorithms (235)
265. could we use tensor network renormalization?
